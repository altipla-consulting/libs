// Package generator helps with creating the symbols files for supported langs
// extracting the data from CLDR.
package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"strconv"
	"strings"

	"github.com/juju/errors"
	"golang.org/x/text/unicode/cldr"
)

var locales = flag.String("locales", "", "Locales to extract from CLDR")

var weekdaysOrder = map[string]int{
	"sun": 0,
	"mon": 1,
	"tue": 2,
	"wed": 3,
	"thu": 4,
	"fri": 5,
	"sat": 6,
}

func main() {
	flag.Parse()

	if err := run(); err != nil {
		log.Fatal(errors.ErrorStack(err))
	}
}

func run() error {
	log.Println("Extract CLDR data")

	coreFile, err := os.Open("/tmp/core.zip")
	if err != nil {
		return errors.Trace(err)
	}

	decoder := cldr.Decoder{}
	decoder.SetDirFilter("main")
	decoder.SetSectionFilter("dates")
	data, err := decoder.DecodeZip(coreFile)
	if err != nil {
		return errors.Trace(err)
	}

	for _, locale := range strings.Split(*locales, ",") {
		log.Println("Extract locale", locale)

		ldml, err := data.LDML(locale)
		if err != nil {
			return errors.Trace(err)
		}

		if err := extractLDML(locale, ldml); err != nil {
			return errors.Trace(err)
		}
	}

	log.Println("Generator done")

	return nil
}

func extractLDML(locale string, ldml *cldr.LDML) error {
	dest, err := os.Create(fmt.Sprintf("symbols/%s.go", locale))
	if err != nil {
		return errors.Trace(err)
	}
	defer dest.Close()

	fmt.Fprintln(dest, "// AUTOGENERATED FROM CLDR DATA. DO NOT EDIT")
	fmt.Fprintln(dest)
	fmt.Fprintln(dest, "package symbols")
	fmt.Fprintln(dest)
	fmt.Fprintln(dest, "func init() {")

	for _, calendar := range ldml.Dates.Calendars.Calendar {
		if calendar.Type != "gregorian" {
			continue
		}

		for _, ctx := range calendar.Months.MonthContext {
			if ctx.Type != "format" {
				continue
			}

			for _, width := range ctx.MonthWidth {
				if width.Type != "wide" && width.Type != "abbreviated" {
					continue
				}

				months := make([]string, 13)
				months[0] = "---"

				for _, month := range width.Month {
					n, err := strconv.ParseInt(month.Type, 10, 64)
					if err != nil {
						return errors.Trace(err)
					}

					months[n] = month.Data()
				}

				nameType := "LongMonthNames"
				if width.Type == "abbreviated" {
					nameType = "ShortMonthNames"
				}

				fmt.Fprintf(dest, "\t%s[`%s`] = []string{\n", nameType, locale)
				for _, m := range months {
					fmt.Fprintf(dest, "\t\t`%s`,\n", m)
				}
				fmt.Fprintln(dest, "\t}")
				fmt.Fprintln(dest)
			}
		}

		for _, ctx := range calendar.Days.DayContext {
			if ctx.Type != "format" {
				continue
			}

			for _, width := range ctx.DayWidth {
				if width.Type != "wide" && width.Type != "abbreviated" {
					continue
				}

				weekdays := make([]string, 7)

				for _, day := range width.Day {
					weekdays[weekdaysOrder[day.Type]] = day.Data()
				}

				nameType := "LongWeekdays"
				if width.Type == "abbreviated" {
					nameType = "ShortWeekdays"
				}

				fmt.Fprintf(dest, "\t%s[`%s`] = []string{\n", nameType, locale)
				for _, d := range weekdays {
					fmt.Fprintf(dest, "\t\t`%s`,\n", d)
				}
				fmt.Fprintln(dest, "\t}")
				fmt.Fprintln(dest)
			}
		}
	}

	fmt.Fprintln(dest, "}")
	fmt.Fprintln(dest)

	return nil
}
